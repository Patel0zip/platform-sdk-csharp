// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: github.com/mwitkow/go-proto-validators/validator.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Validator {

  /// <summary>Holder for reflection information generated from github.com/mwitkow/go-proto-validators/validator.proto</summary>
  public static partial class ValidatorReflection {

    #region Descriptor
    /// <summary>File descriptor for github.com/mwitkow/go-proto-validators/validator.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static ValidatorReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CjZnaXRodWIuY29tL213aXRrb3cvZ28tcHJvdG8tdmFsaWRhdG9ycy92YWxp",
            "ZGF0b3IucHJvdG8SCXZhbGlkYXRvchogZ29vZ2xlL3Byb3RvYnVmL2Rlc2Ny",
            "aXB0b3IucHJvdG8i+gIKDkZpZWxkVmFsaWRhdG9yEg0KBXJlZ2V4GAEgASgJ",
            "Eg4KBmludF9ndBgCIAEoAxIOCgZpbnRfbHQYAyABKAMSEgoKbXNnX2V4aXN0",
            "cxgEIAEoCBITCgtodW1hbl9lcnJvchgFIAEoCRIQCghmbG9hdF9ndBgGIAEo",
            "ARIQCghmbG9hdF9sdBgHIAEoARIVCg1mbG9hdF9lcHNpbG9uGAggASgBEhEK",
            "CWZsb2F0X2d0ZRgJIAEoARIRCglmbG9hdF9sdGUYCiABKAESGAoQc3RyaW5n",
            "X25vdF9lbXB0eRgLIAEoCBIaChJyZXBlYXRlZF9jb3VudF9taW4YDCABKAMS",
            "GgoScmVwZWF0ZWRfY291bnRfbWF4GA0gASgDEhEKCWxlbmd0aF9ndBgOIAEo",
            "AxIRCglsZW5ndGhfbHQYDyABKAMSEQoJbGVuZ3RoX2VxGBAgASgDEhIKCmlz",
            "X2luX2VudW0YESABKAgSEAoIdXVpZF92ZXIYEiABKAUiIgoOT25lb2ZWYWxp",
            "ZGF0b3ISEAoIcmVxdWlyZWQYASABKAg6SQoFZmllbGQSHS5nb29nbGUucHJv",
            "dG9idWYuRmllbGRPcHRpb25zGPz7AyABKAsyGS52YWxpZGF0b3IuRmllbGRW",
            "YWxpZGF0b3I6SQoFb25lb2YSHS5nb29nbGUucHJvdG9idWYuT25lb2ZPcHRp",
            "b25zGP37AyABKAsyGS52YWxpZGF0b3IuT25lb2ZWYWxpZGF0b3JCC1oJdmFs",
            "aWRhdG9y"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Protobuf.Reflection.DescriptorReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pb::Extension[] { ValidatorExtensions.Field, ValidatorExtensions.Oneof }, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Validator.FieldValidator), global::Validator.FieldValidator.Parser, new[]{ "Regex", "IntGt", "IntLt", "MsgExists", "HumanError", "FloatGt", "FloatLt", "FloatEpsilon", "FloatGte", "FloatLte", "StringNotEmpty", "RepeatedCountMin", "RepeatedCountMax", "LengthGt", "LengthLt", "LengthEq", "IsInEnum", "UuidVer" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Validator.OneofValidator), global::Validator.OneofValidator.Parser, new[]{ "Required" }, null, null, null, null)
          }));
    }
    #endregion

  }
  /// <summary>Holder for extension identifiers generated from the top level of github.com/mwitkow/go-proto-validators/validator.proto</summary>
  public static partial class ValidatorExtensions {
    public static readonly pb::Extension<global::Google.Protobuf.Reflection.FieldOptions, global::Validator.FieldValidator> Field =
      new pb::Extension<global::Google.Protobuf.Reflection.FieldOptions, global::Validator.FieldValidator>(65020, pb::FieldCodec.ForMessage(520162, global::Validator.FieldValidator.Parser));
    public static readonly pb::Extension<global::Google.Protobuf.Reflection.OneofOptions, global::Validator.OneofValidator> Oneof =
      new pb::Extension<global::Google.Protobuf.Reflection.OneofOptions, global::Validator.OneofValidator>(65021, pb::FieldCodec.ForMessage(520170, global::Validator.OneofValidator.Parser));
  }

  #region Messages
  public sealed partial class FieldValidator : pb::IMessage<FieldValidator> {
    private static readonly pb::MessageParser<FieldValidator> _parser = new pb::MessageParser<FieldValidator>(() => new FieldValidator());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<FieldValidator> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Validator.ValidatorReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FieldValidator() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FieldValidator(FieldValidator other) : this() {
      _hasBits0 = other._hasBits0;
      regex_ = other.regex_;
      intGt_ = other.intGt_;
      intLt_ = other.intLt_;
      msgExists_ = other.msgExists_;
      humanError_ = other.humanError_;
      floatGt_ = other.floatGt_;
      floatLt_ = other.floatLt_;
      floatEpsilon_ = other.floatEpsilon_;
      floatGte_ = other.floatGte_;
      floatLte_ = other.floatLte_;
      stringNotEmpty_ = other.stringNotEmpty_;
      repeatedCountMin_ = other.repeatedCountMin_;
      repeatedCountMax_ = other.repeatedCountMax_;
      lengthGt_ = other.lengthGt_;
      lengthLt_ = other.lengthLt_;
      lengthEq_ = other.lengthEq_;
      isInEnum_ = other.isInEnum_;
      uuidVer_ = other.uuidVer_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FieldValidator Clone() {
      return new FieldValidator(this);
    }

    /// <summary>Field number for the "regex" field.</summary>
    public const int RegexFieldNumber = 1;
    private readonly static string RegexDefaultValue = "";

    private string regex_;
    /// <summary>
    /// Uses a Golang RE2-syntax regex to match the field contents.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Regex {
      get { return regex_ ?? RegexDefaultValue; }
      set {
        regex_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "regex" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasRegex {
      get { return regex_ != null; }
    }
    /// <summary>Clears the value of the "regex" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRegex() {
      regex_ = null;
    }

    /// <summary>Field number for the "int_gt" field.</summary>
    public const int IntGtFieldNumber = 2;
    private readonly static long IntGtDefaultValue = 0L;

    private long intGt_;
    /// <summary>
    /// Field value of integer strictly greater than this value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long IntGt {
      get { if ((_hasBits0 & 1) != 0) { return intGt_; } else { return IntGtDefaultValue; } }
      set {
        _hasBits0 |= 1;
        intGt_ = value;
      }
    }
    /// <summary>Gets whether the "int_gt" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIntGt {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "int_gt" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIntGt() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "int_lt" field.</summary>
    public const int IntLtFieldNumber = 3;
    private readonly static long IntLtDefaultValue = 0L;

    private long intLt_;
    /// <summary>
    /// Field value of integer strictly smaller than this value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long IntLt {
      get { if ((_hasBits0 & 2) != 0) { return intLt_; } else { return IntLtDefaultValue; } }
      set {
        _hasBits0 |= 2;
        intLt_ = value;
      }
    }
    /// <summary>Gets whether the "int_lt" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIntLt {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "int_lt" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIntLt() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "msg_exists" field.</summary>
    public const int MsgExistsFieldNumber = 4;
    private readonly static bool MsgExistsDefaultValue = false;

    private bool msgExists_;
    /// <summary>
    /// Used for nested message types, requires that the message type exists.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool MsgExists {
      get { if ((_hasBits0 & 4) != 0) { return msgExists_; } else { return MsgExistsDefaultValue; } }
      set {
        _hasBits0 |= 4;
        msgExists_ = value;
      }
    }
    /// <summary>Gets whether the "msg_exists" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasMsgExists {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "msg_exists" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearMsgExists() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "human_error" field.</summary>
    public const int HumanErrorFieldNumber = 5;
    private readonly static string HumanErrorDefaultValue = "";

    private string humanError_;
    /// <summary>
    /// Human error specifies a user-customizable error that is visible to the user.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string HumanError {
      get { return humanError_ ?? HumanErrorDefaultValue; }
      set {
        humanError_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "human_error" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasHumanError {
      get { return humanError_ != null; }
    }
    /// <summary>Clears the value of the "human_error" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearHumanError() {
      humanError_ = null;
    }

    /// <summary>Field number for the "float_gt" field.</summary>
    public const int FloatGtFieldNumber = 6;
    private readonly static double FloatGtDefaultValue = 0D;

    private double floatGt_;
    /// <summary>
    /// Field value of double strictly greater than this value.
    /// Note that this value can only take on a valid floating point
    /// value. Use together with float_epsilon if you need something more specific.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double FloatGt {
      get { if ((_hasBits0 & 8) != 0) { return floatGt_; } else { return FloatGtDefaultValue; } }
      set {
        _hasBits0 |= 8;
        floatGt_ = value;
      }
    }
    /// <summary>Gets whether the "float_gt" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasFloatGt {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "float_gt" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearFloatGt() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "float_lt" field.</summary>
    public const int FloatLtFieldNumber = 7;
    private readonly static double FloatLtDefaultValue = 0D;

    private double floatLt_;
    /// <summary>
    /// Field value of double strictly smaller than this value.
    /// Note that this value can only take on a valid floating point
    /// value. Use together with float_epsilon if you need something more specific.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double FloatLt {
      get { if ((_hasBits0 & 16) != 0) { return floatLt_; } else { return FloatLtDefaultValue; } }
      set {
        _hasBits0 |= 16;
        floatLt_ = value;
      }
    }
    /// <summary>Gets whether the "float_lt" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasFloatLt {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "float_lt" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearFloatLt() {
      _hasBits0 &= ~16;
    }

    /// <summary>Field number for the "float_epsilon" field.</summary>
    public const int FloatEpsilonFieldNumber = 8;
    private readonly static double FloatEpsilonDefaultValue = 0D;

    private double floatEpsilon_;
    /// <summary>
    /// Field value of double describing the epsilon within which
    /// any comparison should be considered to be true. For example,
    /// when using float_gt = 0.35, using a float_epsilon of 0.05
    /// would mean that any value above 0.30 is acceptable. It can be
    /// thought of as a {float_value_condition} +- {float_epsilon}.
    /// If unset, no correction for floating point inaccuracies in
    /// comparisons will be attempted.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double FloatEpsilon {
      get { if ((_hasBits0 & 32) != 0) { return floatEpsilon_; } else { return FloatEpsilonDefaultValue; } }
      set {
        _hasBits0 |= 32;
        floatEpsilon_ = value;
      }
    }
    /// <summary>Gets whether the "float_epsilon" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasFloatEpsilon {
      get { return (_hasBits0 & 32) != 0; }
    }
    /// <summary>Clears the value of the "float_epsilon" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearFloatEpsilon() {
      _hasBits0 &= ~32;
    }

    /// <summary>Field number for the "float_gte" field.</summary>
    public const int FloatGteFieldNumber = 9;
    private readonly static double FloatGteDefaultValue = 0D;

    private double floatGte_;
    /// <summary>
    /// Floating-point value compared to which the field content should be greater or equal.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double FloatGte {
      get { if ((_hasBits0 & 64) != 0) { return floatGte_; } else { return FloatGteDefaultValue; } }
      set {
        _hasBits0 |= 64;
        floatGte_ = value;
      }
    }
    /// <summary>Gets whether the "float_gte" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasFloatGte {
      get { return (_hasBits0 & 64) != 0; }
    }
    /// <summary>Clears the value of the "float_gte" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearFloatGte() {
      _hasBits0 &= ~64;
    }

    /// <summary>Field number for the "float_lte" field.</summary>
    public const int FloatLteFieldNumber = 10;
    private readonly static double FloatLteDefaultValue = 0D;

    private double floatLte_;
    /// <summary>
    /// Floating-point value compared to which the field content should be smaller or equal.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double FloatLte {
      get { if ((_hasBits0 & 128) != 0) { return floatLte_; } else { return FloatLteDefaultValue; } }
      set {
        _hasBits0 |= 128;
        floatLte_ = value;
      }
    }
    /// <summary>Gets whether the "float_lte" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasFloatLte {
      get { return (_hasBits0 & 128) != 0; }
    }
    /// <summary>Clears the value of the "float_lte" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearFloatLte() {
      _hasBits0 &= ~128;
    }

    /// <summary>Field number for the "string_not_empty" field.</summary>
    public const int StringNotEmptyFieldNumber = 11;
    private readonly static bool StringNotEmptyDefaultValue = false;

    private bool stringNotEmpty_;
    /// <summary>
    /// Used for string fields, requires the string to be not empty (i.e different from "").
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool StringNotEmpty {
      get { if ((_hasBits0 & 256) != 0) { return stringNotEmpty_; } else { return StringNotEmptyDefaultValue; } }
      set {
        _hasBits0 |= 256;
        stringNotEmpty_ = value;
      }
    }
    /// <summary>Gets whether the "string_not_empty" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasStringNotEmpty {
      get { return (_hasBits0 & 256) != 0; }
    }
    /// <summary>Clears the value of the "string_not_empty" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearStringNotEmpty() {
      _hasBits0 &= ~256;
    }

    /// <summary>Field number for the "repeated_count_min" field.</summary>
    public const int RepeatedCountMinFieldNumber = 12;
    private readonly static long RepeatedCountMinDefaultValue = 0L;

    private long repeatedCountMin_;
    /// <summary>
    /// Repeated field with at least this number of elements.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long RepeatedCountMin {
      get { if ((_hasBits0 & 512) != 0) { return repeatedCountMin_; } else { return RepeatedCountMinDefaultValue; } }
      set {
        _hasBits0 |= 512;
        repeatedCountMin_ = value;
      }
    }
    /// <summary>Gets whether the "repeated_count_min" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasRepeatedCountMin {
      get { return (_hasBits0 & 512) != 0; }
    }
    /// <summary>Clears the value of the "repeated_count_min" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRepeatedCountMin() {
      _hasBits0 &= ~512;
    }

    /// <summary>Field number for the "repeated_count_max" field.</summary>
    public const int RepeatedCountMaxFieldNumber = 13;
    private readonly static long RepeatedCountMaxDefaultValue = 0L;

    private long repeatedCountMax_;
    /// <summary>
    /// Repeated field with at most this number of elements.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long RepeatedCountMax {
      get { if ((_hasBits0 & 1024) != 0) { return repeatedCountMax_; } else { return RepeatedCountMaxDefaultValue; } }
      set {
        _hasBits0 |= 1024;
        repeatedCountMax_ = value;
      }
    }
    /// <summary>Gets whether the "repeated_count_max" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasRepeatedCountMax {
      get { return (_hasBits0 & 1024) != 0; }
    }
    /// <summary>Clears the value of the "repeated_count_max" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRepeatedCountMax() {
      _hasBits0 &= ~1024;
    }

    /// <summary>Field number for the "length_gt" field.</summary>
    public const int LengthGtFieldNumber = 14;
    private readonly static long LengthGtDefaultValue = 0L;

    private long lengthGt_;
    /// <summary>
    /// Field value of length greater than this value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long LengthGt {
      get { if ((_hasBits0 & 2048) != 0) { return lengthGt_; } else { return LengthGtDefaultValue; } }
      set {
        _hasBits0 |= 2048;
        lengthGt_ = value;
      }
    }
    /// <summary>Gets whether the "length_gt" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasLengthGt {
      get { return (_hasBits0 & 2048) != 0; }
    }
    /// <summary>Clears the value of the "length_gt" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearLengthGt() {
      _hasBits0 &= ~2048;
    }

    /// <summary>Field number for the "length_lt" field.</summary>
    public const int LengthLtFieldNumber = 15;
    private readonly static long LengthLtDefaultValue = 0L;

    private long lengthLt_;
    /// <summary>
    /// Field value of length smaller than this value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long LengthLt {
      get { if ((_hasBits0 & 4096) != 0) { return lengthLt_; } else { return LengthLtDefaultValue; } }
      set {
        _hasBits0 |= 4096;
        lengthLt_ = value;
      }
    }
    /// <summary>Gets whether the "length_lt" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasLengthLt {
      get { return (_hasBits0 & 4096) != 0; }
    }
    /// <summary>Clears the value of the "length_lt" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearLengthLt() {
      _hasBits0 &= ~4096;
    }

    /// <summary>Field number for the "length_eq" field.</summary>
    public const int LengthEqFieldNumber = 16;
    private readonly static long LengthEqDefaultValue = 0L;

    private long lengthEq_;
    /// <summary>
    /// Field value of length strictly equal to this value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long LengthEq {
      get { if ((_hasBits0 & 8192) != 0) { return lengthEq_; } else { return LengthEqDefaultValue; } }
      set {
        _hasBits0 |= 8192;
        lengthEq_ = value;
      }
    }
    /// <summary>Gets whether the "length_eq" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasLengthEq {
      get { return (_hasBits0 & 8192) != 0; }
    }
    /// <summary>Clears the value of the "length_eq" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearLengthEq() {
      _hasBits0 &= ~8192;
    }

    /// <summary>Field number for the "is_in_enum" field.</summary>
    public const int IsInEnumFieldNumber = 17;
    private readonly static bool IsInEnumDefaultValue = false;

    private bool isInEnum_;
    /// <summary>
    /// Requires that the value is in the enum.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsInEnum {
      get { if ((_hasBits0 & 16384) != 0) { return isInEnum_; } else { return IsInEnumDefaultValue; } }
      set {
        _hasBits0 |= 16384;
        isInEnum_ = value;
      }
    }
    /// <summary>Gets whether the "is_in_enum" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasIsInEnum {
      get { return (_hasBits0 & 16384) != 0; }
    }
    /// <summary>Clears the value of the "is_in_enum" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearIsInEnum() {
      _hasBits0 &= ~16384;
    }

    /// <summary>Field number for the "uuid_ver" field.</summary>
    public const int UuidVerFieldNumber = 18;
    private readonly static int UuidVerDefaultValue = 0;

    private int uuidVer_;
    /// <summary>
    /// Ensures that a string value is in UUID format.
    /// uuid_ver specifies the valid UUID versions. Valid values are: 0-5.
    /// If uuid_ver is 0 all UUID versions are accepted.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int UuidVer {
      get { if ((_hasBits0 & 32768) != 0) { return uuidVer_; } else { return UuidVerDefaultValue; } }
      set {
        _hasBits0 |= 32768;
        uuidVer_ = value;
      }
    }
    /// <summary>Gets whether the "uuid_ver" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasUuidVer {
      get { return (_hasBits0 & 32768) != 0; }
    }
    /// <summary>Clears the value of the "uuid_ver" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearUuidVer() {
      _hasBits0 &= ~32768;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as FieldValidator);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(FieldValidator other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Regex != other.Regex) return false;
      if (IntGt != other.IntGt) return false;
      if (IntLt != other.IntLt) return false;
      if (MsgExists != other.MsgExists) return false;
      if (HumanError != other.HumanError) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(FloatGt, other.FloatGt)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(FloatLt, other.FloatLt)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(FloatEpsilon, other.FloatEpsilon)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(FloatGte, other.FloatGte)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(FloatLte, other.FloatLte)) return false;
      if (StringNotEmpty != other.StringNotEmpty) return false;
      if (RepeatedCountMin != other.RepeatedCountMin) return false;
      if (RepeatedCountMax != other.RepeatedCountMax) return false;
      if (LengthGt != other.LengthGt) return false;
      if (LengthLt != other.LengthLt) return false;
      if (LengthEq != other.LengthEq) return false;
      if (IsInEnum != other.IsInEnum) return false;
      if (UuidVer != other.UuidVer) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasRegex) hash ^= Regex.GetHashCode();
      if (HasIntGt) hash ^= IntGt.GetHashCode();
      if (HasIntLt) hash ^= IntLt.GetHashCode();
      if (HasMsgExists) hash ^= MsgExists.GetHashCode();
      if (HasHumanError) hash ^= HumanError.GetHashCode();
      if (HasFloatGt) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(FloatGt);
      if (HasFloatLt) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(FloatLt);
      if (HasFloatEpsilon) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(FloatEpsilon);
      if (HasFloatGte) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(FloatGte);
      if (HasFloatLte) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(FloatLte);
      if (HasStringNotEmpty) hash ^= StringNotEmpty.GetHashCode();
      if (HasRepeatedCountMin) hash ^= RepeatedCountMin.GetHashCode();
      if (HasRepeatedCountMax) hash ^= RepeatedCountMax.GetHashCode();
      if (HasLengthGt) hash ^= LengthGt.GetHashCode();
      if (HasLengthLt) hash ^= LengthLt.GetHashCode();
      if (HasLengthEq) hash ^= LengthEq.GetHashCode();
      if (HasIsInEnum) hash ^= IsInEnum.GetHashCode();
      if (HasUuidVer) hash ^= UuidVer.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (HasRegex) {
        output.WriteRawTag(10);
        output.WriteString(Regex);
      }
      if (HasIntGt) {
        output.WriteRawTag(16);
        output.WriteInt64(IntGt);
      }
      if (HasIntLt) {
        output.WriteRawTag(24);
        output.WriteInt64(IntLt);
      }
      if (HasMsgExists) {
        output.WriteRawTag(32);
        output.WriteBool(MsgExists);
      }
      if (HasHumanError) {
        output.WriteRawTag(42);
        output.WriteString(HumanError);
      }
      if (HasFloatGt) {
        output.WriteRawTag(49);
        output.WriteDouble(FloatGt);
      }
      if (HasFloatLt) {
        output.WriteRawTag(57);
        output.WriteDouble(FloatLt);
      }
      if (HasFloatEpsilon) {
        output.WriteRawTag(65);
        output.WriteDouble(FloatEpsilon);
      }
      if (HasFloatGte) {
        output.WriteRawTag(73);
        output.WriteDouble(FloatGte);
      }
      if (HasFloatLte) {
        output.WriteRawTag(81);
        output.WriteDouble(FloatLte);
      }
      if (HasStringNotEmpty) {
        output.WriteRawTag(88);
        output.WriteBool(StringNotEmpty);
      }
      if (HasRepeatedCountMin) {
        output.WriteRawTag(96);
        output.WriteInt64(RepeatedCountMin);
      }
      if (HasRepeatedCountMax) {
        output.WriteRawTag(104);
        output.WriteInt64(RepeatedCountMax);
      }
      if (HasLengthGt) {
        output.WriteRawTag(112);
        output.WriteInt64(LengthGt);
      }
      if (HasLengthLt) {
        output.WriteRawTag(120);
        output.WriteInt64(LengthLt);
      }
      if (HasLengthEq) {
        output.WriteRawTag(128, 1);
        output.WriteInt64(LengthEq);
      }
      if (HasIsInEnum) {
        output.WriteRawTag(136, 1);
        output.WriteBool(IsInEnum);
      }
      if (HasUuidVer) {
        output.WriteRawTag(144, 1);
        output.WriteInt32(UuidVer);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasRegex) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Regex);
      }
      if (HasIntGt) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(IntGt);
      }
      if (HasIntLt) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(IntLt);
      }
      if (HasMsgExists) {
        size += 1 + 1;
      }
      if (HasHumanError) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(HumanError);
      }
      if (HasFloatGt) {
        size += 1 + 8;
      }
      if (HasFloatLt) {
        size += 1 + 8;
      }
      if (HasFloatEpsilon) {
        size += 1 + 8;
      }
      if (HasFloatGte) {
        size += 1 + 8;
      }
      if (HasFloatLte) {
        size += 1 + 8;
      }
      if (HasStringNotEmpty) {
        size += 1 + 1;
      }
      if (HasRepeatedCountMin) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(RepeatedCountMin);
      }
      if (HasRepeatedCountMax) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(RepeatedCountMax);
      }
      if (HasLengthGt) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(LengthGt);
      }
      if (HasLengthLt) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(LengthLt);
      }
      if (HasLengthEq) {
        size += 2 + pb::CodedOutputStream.ComputeInt64Size(LengthEq);
      }
      if (HasIsInEnum) {
        size += 2 + 1;
      }
      if (HasUuidVer) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(UuidVer);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(FieldValidator other) {
      if (other == null) {
        return;
      }
      if (other.HasRegex) {
        Regex = other.Regex;
      }
      if (other.HasIntGt) {
        IntGt = other.IntGt;
      }
      if (other.HasIntLt) {
        IntLt = other.IntLt;
      }
      if (other.HasMsgExists) {
        MsgExists = other.MsgExists;
      }
      if (other.HasHumanError) {
        HumanError = other.HumanError;
      }
      if (other.HasFloatGt) {
        FloatGt = other.FloatGt;
      }
      if (other.HasFloatLt) {
        FloatLt = other.FloatLt;
      }
      if (other.HasFloatEpsilon) {
        FloatEpsilon = other.FloatEpsilon;
      }
      if (other.HasFloatGte) {
        FloatGte = other.FloatGte;
      }
      if (other.HasFloatLte) {
        FloatLte = other.FloatLte;
      }
      if (other.HasStringNotEmpty) {
        StringNotEmpty = other.StringNotEmpty;
      }
      if (other.HasRepeatedCountMin) {
        RepeatedCountMin = other.RepeatedCountMin;
      }
      if (other.HasRepeatedCountMax) {
        RepeatedCountMax = other.RepeatedCountMax;
      }
      if (other.HasLengthGt) {
        LengthGt = other.LengthGt;
      }
      if (other.HasLengthLt) {
        LengthLt = other.LengthLt;
      }
      if (other.HasLengthEq) {
        LengthEq = other.LengthEq;
      }
      if (other.HasIsInEnum) {
        IsInEnum = other.IsInEnum;
      }
      if (other.HasUuidVer) {
        UuidVer = other.UuidVer;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Regex = input.ReadString();
            break;
          }
          case 16: {
            IntGt = input.ReadInt64();
            break;
          }
          case 24: {
            IntLt = input.ReadInt64();
            break;
          }
          case 32: {
            MsgExists = input.ReadBool();
            break;
          }
          case 42: {
            HumanError = input.ReadString();
            break;
          }
          case 49: {
            FloatGt = input.ReadDouble();
            break;
          }
          case 57: {
            FloatLt = input.ReadDouble();
            break;
          }
          case 65: {
            FloatEpsilon = input.ReadDouble();
            break;
          }
          case 73: {
            FloatGte = input.ReadDouble();
            break;
          }
          case 81: {
            FloatLte = input.ReadDouble();
            break;
          }
          case 88: {
            StringNotEmpty = input.ReadBool();
            break;
          }
          case 96: {
            RepeatedCountMin = input.ReadInt64();
            break;
          }
          case 104: {
            RepeatedCountMax = input.ReadInt64();
            break;
          }
          case 112: {
            LengthGt = input.ReadInt64();
            break;
          }
          case 120: {
            LengthLt = input.ReadInt64();
            break;
          }
          case 128: {
            LengthEq = input.ReadInt64();
            break;
          }
          case 136: {
            IsInEnum = input.ReadBool();
            break;
          }
          case 144: {
            UuidVer = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  public sealed partial class OneofValidator : pb::IMessage<OneofValidator> {
    private static readonly pb::MessageParser<OneofValidator> _parser = new pb::MessageParser<OneofValidator>(() => new OneofValidator());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<OneofValidator> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Validator.ValidatorReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OneofValidator() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OneofValidator(OneofValidator other) : this() {
      _hasBits0 = other._hasBits0;
      required_ = other.required_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OneofValidator Clone() {
      return new OneofValidator(this);
    }

    /// <summary>Field number for the "required" field.</summary>
    public const int RequiredFieldNumber = 1;
    private readonly static bool RequiredDefaultValue = false;

    private bool required_;
    /// <summary>
    /// Require that one of the oneof fields is set.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Required {
      get { if ((_hasBits0 & 1) != 0) { return required_; } else { return RequiredDefaultValue; } }
      set {
        _hasBits0 |= 1;
        required_ = value;
      }
    }
    /// <summary>Gets whether the "required" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasRequired {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "required" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearRequired() {
      _hasBits0 &= ~1;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as OneofValidator);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(OneofValidator other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Required != other.Required) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasRequired) hash ^= Required.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (HasRequired) {
        output.WriteRawTag(8);
        output.WriteBool(Required);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasRequired) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(OneofValidator other) {
      if (other == null) {
        return;
      }
      if (other.HasRequired) {
        Required = other.Required;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Required = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
